From e6dba275ded6a9e5c63883763fef21f519822b39 Mon Sep 17 00:00:00 2001
From: W_Y_CPP <383152993@qq.com>
Date: Mon, 7 Feb 2022 23:19:06 -0500
Subject: [PATCH] Revert-pinctrl-bcm2835-Pass-irqchip-when-adding-gpio

---
 drivers/pinctrl/bcm/pinctrl-bcm2835.c | 131 +++++++++-----------------
 1 file changed, 43 insertions(+), 88 deletions(-)

diff --git a/drivers/pinctrl/bcm/pinctrl-bcm2835.c b/drivers/pinctrl/bcm/pinctrl-bcm2835.c
index 8724b9076..8ada95f60 100644
--- a/drivers/pinctrl/bcm/pinctrl-bcm2835.c
+++ b/drivers/pinctrl/bcm/pinctrl-bcm2835.c
@@ -78,7 +78,7 @@ struct bcm2835_pinctrl {
 	struct device *dev;
 	void __iomem *base;
 	int *wake_irq;
-
+	int irq[BCM2835_NUM_IRQS];
 	/* note: locking assumes each bank will have its own unsigned long */
 	unsigned long enabled_irq_map[BCM2835_NUM_BANKS];
 	unsigned int irq_type[BCM2711_NUM_GPIOS];
@@ -406,14 +406,14 @@ static void bcm2835_gpio_irq_handler(struct irq_desc *desc)
 	int group;
 	int i;
 
-	for (i = 0; i < BCM2835_NUM_IRQS; i++) {
-		if (chip->irq.parents[i] == irq) {
+	for (i = 0; i < ARRAY_SIZE(pc->irq); i++) {
+		if (pc->irq[i] == irq) {
 			group = i;
 			break;
 		}
 	}
 	/* This should not happen, every IRQ has a bank */
-	if (i == BCM2835_NUM_IRQS)
+	if (i == ARRAY_SIZE(pc->irq))
 		BUG();
 
 	chained_irq_enter(host_chip, desc);
@@ -1182,16 +1182,14 @@ static int bcm2835_pinctrl_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
-	const struct bcm_plat_data *pdata;
 	struct bcm2835_pinctrl *pc;
-	struct gpio_irq_chip *girq;
 	struct resource iomem;
 	int err, i;
 	const struct of_device_id *match;
-	int is_7211 = 0;
+	const struct bcm_plat_data *pdata;
 
-	BUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_pins) != BCM2711_NUM_GPIOS);
-	BUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_groups) != BCM2711_NUM_GPIOS);
+	BUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_pins) != BCM2711_NUM_GPIOS);
+	BUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_groups) != BCM2711_NUM_GPIOS);
 
 	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
 	if (!pc)
@@ -1210,14 +1208,6 @@ static int bcm2835_pinctrl_probe(struct platform_device *pdev)
 	if (IS_ERR(pc->base))
 		return PTR_ERR(pc->base);
 
-	match = of_match_node(bcm2835_pinctrl_match, pdev->dev.of_node);
-	if (!match)
-		return -EINVAL;
-
-	pdata = match->data;
-	is_7211 = of_device_is_compatible(np, "brcm,bcm7211-gpio");
-
-	pc->gpio_chip = *pdata->gpio_chip;
 	pc->gpio_chip.parent = dev;
 	pc->gpio_chip.of_node = np;
 
@@ -1241,89 +1231,54 @@ static int bcm2835_pinctrl_probe(struct platform_device *pdev)
 		raw_spin_lock_init(&pc->irq_lock[i]);
 	}
 
-	match = of_match_node(bcm2835_pinctrl_match, pdev->dev.of_node);
-	if (match) {
-		bcm2835_pinctrl_desc.confops =
-			(const struct pinconf_ops *)match->data;
-	}
-
-	pc->pctl_desc = *pdata->pctl_desc;
-	pc->pctl_dev = devm_pinctrl_register(dev, &pc->pctl_desc, pc);
-	if (IS_ERR(pc->pctl_dev)) {
-		gpiochip_remove(&pc->gpio_chip);
-		return PTR_ERR(pc->pctl_dev);
-	}
-
-	pc->gpio_range = *pdata->gpio_range;
-	pc->gpio_range.base = pc->gpio_chip.base;
-	pc->gpio_range.gc = &pc->gpio_chip;
-	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
-
-	girq = &pc->gpio_chip.irq;
-	girq->chip = &bcm2835_gpio_irq_chip;
-	girq->parent_handler = bcm2835_gpio_irq_handler;
-	girq->num_parents = BCM2835_NUM_IRQS;
-	girq->parents = devm_kcalloc(dev, BCM2835_NUM_IRQS,
-				     sizeof(*girq->parents),
-				     GFP_KERNEL);
-	if (!girq->parents) {
-		pinctrl_remove_gpio_range(pc->pctl_dev, &pc->gpio_range);
-		return -ENOMEM;
+	err = gpiochip_add_data(&pc->gpio_chip, pc);
+	if (err) {
+		dev_err(dev, "could not add GPIO chip\n");
+		return err;
 	}
 
-	if (is_7211) {
-		pc->wake_irq = devm_kcalloc(dev, BCM2835_NUM_IRQS,
-					    sizeof(*pc->wake_irq),
-					    GFP_KERNEL);
-		if (!pc->wake_irq)
-			return -ENOMEM;
+	err = gpiochip_irqchip_add(&pc->gpio_chip, &bcm2835_gpio_irq_chip,
+				   0, handle_level_irq, IRQ_TYPE_NONE);
+	if (err) {
+		dev_info(dev, "could not add irqchip\n");
+		return err;
 	}
 
-	/*
-	 * Use the same handler for all groups: this is necessary
-	 * since we use one gpiochip to cover all lines - the
-	 * irq handler then needs to figure out which group and
-	 * bank that was firing the IRQ and look up the per-group
-	 * and bank data.
-	 */
 	for (i = 0; i < BCM2835_NUM_IRQS; i++) {
-		int len;
-		char *name;
+		pc->irq[i] = irq_of_parse_and_map(np, i);
 
-		girq->parents[i] = irq_of_parse_and_map(np, i);
-		if (!is_7211)
+		if (pc->irq[i] == 0)
 			continue;
 
-		/* Skip over the all banks interrupts */
-		pc->wake_irq[i] = irq_of_parse_and_map(np, i +
-						       BCM2835_NUM_IRQS + 1);
-
-		len = strlen(dev_name(pc->dev)) + 16;
-		name = devm_kzalloc(pc->dev, len, GFP_KERNEL);
-		if (!name)
-			return -ENOMEM;
-
-		snprintf(name, len, "%s:bank%d", dev_name(pc->dev), i);
-
-		/* These are optional interrupts */
-		err = devm_request_irq(dev, pc->wake_irq[i],
-				       bcm2835_gpio_wake_irq_handler,
-				       IRQF_SHARED, name, pc);
-		if (err)
-			dev_warn(dev, "unable to request wake IRQ %d\n",
-				 pc->wake_irq[i]);
+		/*
+		 * Use the same handler for all groups: this is necessary
+		 * since we use one gpiochip to cover all lines - the
+		 * irq handler then needs to figure out which group and
+		 * bank that was firing the IRQ and look up the per-group
+		 * and bank data.
+		 */
+		gpiochip_set_chained_irqchip(&pc->gpio_chip,
+					     &bcm2835_gpio_irq_chip,
+					     pc->irq[i],
+					     bcm2835_gpio_irq_handler);
 	}
 
-	girq->default_type = IRQ_TYPE_NONE;
-	girq->handler = handle_level_irq;
-
-	err = gpiochip_add_data(&pc->gpio_chip, pc);
-	if (err) {
-		dev_err(dev, "could not add GPIO chip\n");
-		pinctrl_remove_gpio_range(pc->pctl_dev, &pc->gpio_range);
-		return err;
+	match = of_match_node(bcm2835_pinctrl_match, pdev->dev.of_node);
+	if (!match)
+		return -EINVAL;
+	pdata = match->data;
+	pc->gpio_chip =*pdata->gpio_chip;
+	pc->pctl_dev = devm_pinctrl_register(dev, &(*pdata->pctl_desc), pc);
+	if (IS_ERR(pc->pctl_dev)) {
+		gpiochip_remove(&pc->gpio_chip);
+		return PTR_ERR(pc->pctl_dev);
 	}
 
+	pc->gpio_range = *pdata->gpio_range;
+	pc->gpio_range.base = pc->gpio_chip.base;
+	pc->gpio_range.gc = &pc->gpio_chip;
+	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
+
 	return 0;
 }
 
-- 
2.17.1

